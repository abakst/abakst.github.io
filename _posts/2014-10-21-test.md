---
title: From Tests to Proofs
authors: Ashutosh Gupta, Rupak Majumdar, Andrey Rybalchenko
---
<!-- -->
Crucial to any automatic verification tool is a technique for 
automatically generating the (inductive) invariants required to
prove a program in the presence of loops. While techinques such as
abstract interpretation are effective at divining the correct invariants,
in practice these tools tend to choke on "large" programs (for some definition
of large).
<!-- -->

Enter "From Tests To Proofs." To improve the scalability of automatic
verifiers, the authors propose the following scheme. First, we assume

1.    A suitable language for writing program invariants over program states
(maps from variables to values) -- the authors use linear inequalities.

2.    An invariant *template* scheme -- in this paper, of the form

      α₀ + α₁·```x₁``` + αₙ·```x₂``` + ... ≤ 0
  
      where each ```xᵢ``` is a program variable. Invariants are generated
      by instantiating each αᵢ with a rational number. 

At each program point, we create a *template* invariant using the
selected scheme. Next, for each transition in the program, we 
create a constraint. Given the program

    int x;
    int y;
    x = y + 1;

the template at line 2

α₀ + α₁·```x``` + α₂·```y```  ≤ 0

and the template at line 3

β₀ + β₁·```x``` + β₂·```y```  ≤ 0

We would create the following constraint from line 2 to line 3:

α₀ + α₁·```x``` + αₙ·```y```  ≤ 0 → β₀ + β₁·```y + 1``` + β₂```y``` ≤ 0

which encodes the fact that ```x``` is updated to ```y+1```.


After some linear algebra, we obtain a system of these kinds of constraints.

## Key Idea

This set up is all fairly standard. The main idea, then, is to simplify these
constraints. 

The first method is static -- use an abstract interpretation to figure
out invariants at each program point. These invariants are added as
conjunts to each constraint.

The next method is quite interesting -- namely, simplifying constraints
by using *tests*, as the title would suggest. The key observation is
that dynamic execution of the program reveals additional constraints. 

That is, since we are computing an *invariant*, if we observe the
program at a particular state, the invariant had better hold on that
particular state. Simplification from tests is performed essentially by

1. Generating and running a test

2. At each program point, *instantiating* the invariant template with
*actual* run-time values, and adding the instantiated template to
the relevant constraint (assuming that the test is not a counterexample).

Given the above program, suppose we ran a test with ```x = 0``` and ```y = 0```.
Substituting this valuation yields the following constraint in addition
to the implications generated by ```InvGen```:

α₀ ≤ 0 ∧ β₀ + β₁·```1``` ≤ 0


Symbolic execution can be substituted for test generation/execution in 
a very similar way.

Of course, the rest of the paper goes on to talk about the effectiveness
of combining tests/symbolic execution with the other static techniques.

## Questions for future directions

The key insight is that observing real program states give concrete values
that may make constraint systems easier to solve. The paper showed the
effectiveness in the domain of linear arithmetic inequalities.

A lingering question is *how to effectively determine templates*. It
seems that this technique relies on generating the correct templates,
but the authors only suggest that templates may be tuned by
adding/removing conjuncts. Furthermore, it isn't entirely clear how to
move from LIA to other domains (such as predicate abstraction).
